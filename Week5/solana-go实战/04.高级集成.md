# 实时事件集成教程

## 1. WebSocket 事件订阅
```go
package main

import (
    "context"
    "fmt"
    "github.com/portto/solana-go-sdk/client"
    "github.com/portto/solana-go-sdk/rpc/ws"
)

func main() {
    // 创建WebSocket客户端（连接到DevNet）
    wsClient, err := ws.Connect(context.Background(), rpc.DevnetWS)
    if err != nil {
        panic("连接失败: " + err.Error())
    }

    // 订阅程序日志（示例：SPL Token程序）
    sub, err := wsClient.LogsSubscribeMatching(
        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        rpc.CommitmentConfirmed,
    )
    if err != nil {
        panic("订阅失败: " + err.Error())
    }
    defer sub.Unsubscribe()

    // 实时处理事件
    for {
        select {
        case log := <-sub.Channel():
            fmt.Printf("[程序日志] 账户: %s\n", log.Value.Pubkey)
            fmt.Printf("      日志内容: %+v\n", log.Value.Logs)
        case err := <-sub.Err():
            fmt.Printf("监听错误: %v\n", err)
            return
        }
    }
}
```

## 2. 日志解析实战
```go
package main

import (
    "encoding/json"
    "github.com/portto/solana-go-sdk/common"
    "github.com/portto/solana-go-sdk/program/token"
)

// 代币转账事件结构
type TokenTransfer struct {
    Source     common.PublicKey `json:"source"`
    Destination common.PublicKey `json:"destination"`
    Amount     uint64           `json:"amount"`
}

func parseTokenTransfer(logs []string) (*TokenTransfer, error) {
    // 查找转账指令日志
    for _, l := range logs {
        if token.IsTransferInstructionLog(l) {
            // 示例日志格式："Program log: Instruction: Transfer, 
            // Amount=100000000"
            return &TokenTransfer{
                Source:     common.PublicKeyFromString(logs[2]), // 账户位置固定
                Destination: common.PublicKeyFromString(logs[3]),
                Amount:     extractAmountFromLog(l),
            }, nil
        }
    }
    return nil, errors.New("未找到转账事件")
}

// 从日志字符串提取金额
func extractAmountFromLog(log string) uint64 {
    var amount struct {
        Value uint64 `json:"Amount"`
    }
    json.Unmarshal([]byte(log[15:]), &amount) // 跳过"Program log: "前缀
    return amount.Value
}
```

## 3. 集成测试方案
```bash
# 测试事件监听（新终端运行）
go run event_subscribe.go

# 触发测试交易（示例转账）
go run transaction_flow.go
```

## 4. 生产环境技巧
```go
// 带缓冲的事件通道
eventChan := make(chan rpc.LogResult, 100)

// 上下文超时控制
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
defer cancel()

// 错误重试机制
retry.WithBackoff(ctx, 3, func() error {
    return wsClient.Reconnect()
})

// 优雅关闭
defer func() {
    sub.Unsubscribe()
    wsClient.Close()
}()
```

## 5. 实际应用场景
1. **代币转账监控**  
   ```go
   // 监听SPL Token合约地址
   sub, _ := wsClient.LogsSubscribeMatching("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
   ```

2. **NFT铸造通知**  
   ```go
   // 解析Metadata日志
   if strings.Contains(log, "initializeMetadata") {
       parseNFTMetadata(logs)
   }
   ```

3. **质押状态更新**  
   ```go
   // 监听Stake程序事件
   sub, _ := wsClient.LogsSubscribeMatching("Stake11111111111111111111111111111111111111")
   ```

## 6. 验证检查点
✅ 运行事件监听程序后能收到实时通知  
✅ 解析后的转账金额与实际交易一致  
✅ 网络断开后能自动重连  
✅ 程序退出时正确释放连接资源

